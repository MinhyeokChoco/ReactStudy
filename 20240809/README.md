# React란 ?

## 탄생 배경
> React는 프론트 엔드 라이브러리
> 공식 홈페이지에서도 '라이브러리' 라고 한다.

## 라이브러리와 프레임워크의 차이
1. 프레임워크 (NestJS)
- 디렉터리의 구성이 있다.

2. 라이브러리 (NodeJS)
- 디렉터리의 구성이 없다.

## 프론트 엔드의 3대장
Angular : 지금은 사용을 잘 안함, 하지만 NestJS에서 참고할 정도로 괜찮음
Vue(nuxt) : 양방향 데이터 전달 가능, 소규모 프로젝트 이용 시 유용
- nuxt : 프레임워크
React(next) : 단방향 데이터 전달 가능, 대규모 프로젝트 이용 시 유용
- next : 프레임워크

> SPA의 이전 세대
> 자바스크립트의 DOM 제어를 어떻게 편하게 할 수 있을까 ?
> jquery를 사용하던 시대 (코드가 간결하고, 막 써도 다 됩니다.) (심지어 자바스크립트를 모르는 사람도 제이쿼리를 외워서 씀) (반복문도 모르는 사람이 DOM 제어를 할 수 있음)
> 제이쿼리의 문제점 : 아무렇게나 작성해도 구현이 된다고 생각하기 때문에, 자바스크립트를 모르고 사용하는 사람들이 발생
    여기서 큰 문제점 : 가독성 많이 떨어짐, 최적화가 아예 안됨, 엄청 무거운 프로젝트가 탄생
> jquery를 사용하려면 'npm i'로 설치 받거나, cdn으로 script src로 설치 받아서 사용
> 2006년에 john Resig가 제이쿼리를 발표
> DOM 제어가 무척 쉬웠다. 제이쿼리가 표준이라는 말이 나올 정도로 돔제어가 쉽고 크로스 브라우징 가능
> 초기 시절에는 인기가 많았다.

> SPA : 싱글 페이지 어플리케이션
> 웹페이지를 사용하는데 마치 앱을 사용하는 것 같은 사용감 (사용성이 부드럽다.)
> SPA의 초기 사례 : Google의 gmail(인기가 만점)(웹페이지에서 앱처럼 동작)
> Backbone, AngularJS를 사용한 SPA 환경을 구축 했고 DOM을 다루는 방식은 제이쿼리
> React가 탄생
> React의 개념은 탄생 했을 때 11년 이상은 가지고 놀 수 있는 기술이 될 것 같다.
> React도 많은 플랫폼 중에 에어비엔비, 넷플릭스
> React는 많은 개발자들 사이에서 자연스럽게 생태계가 커지게 됨.
> 제이쿼리의 DOM 제어를 사용할 필요가 없다.
> React의 가상돔을 사용해서 제어
> 부분 렌더링이 가능하다.

# React
- SPA
- 보여주는 하나의 페이지를 중심으로 view가 중심인 어플리케이션
- react router dom 페이지가 이동한 것 같은 느낌을 줄 수 있다.

## 특징

1. 데이터의 흐름 : 부모가 자식한테만 데이터를 전달 할 수 있다. 즉, 단방향 전송이다.
ex : `A(부모) => B(자식)` 가능, `B(자식) => A(부모)` 안됨
리액트는 단방향 데이터의 흐름이고 / vue, angular는 양방향 데이터의 바인딩을 가지고 있다.
- 그렇다면 대규모 프로젝트에서 vue와 angular을 쓰지 않는 이유 : 개발하고 있는 프로젝트가 커질 수록 데이터의 흐름을 유추하기가 힘들다.
> react는 단방향 통신으로 데이터의 흐름을 부모를 따라가서 유추하기가 수월한데
> vue와 angular는 양방향 통신으로 아예 다른 폴더나 다른 프로젝트에서 병합했을 때 넘어온건지 등등 유추하기가 어려워진다. (마인드맵 처럼 그림을 그려보면 이해하기 쉬움)

2. 컴포넌트의 구조
- 컴포넌트와 컴포넌트 구조 : 컴포넌트는 하나의 객체 페이지의 구성 요소의 하나의 UI 단위, UI 여러개로 나눠 놓은 것.

3. 가상돔
- DOM은 html과 css의 내용을 트리구조를 이용하여 가지고 있고 *
- 브라우저는 DOM이 변경되면 화면을 다시 그리는데 DOM이 변경된 비용이 비싼게 아니고 변경이 된 후의 동작이 비싸다.
- 페인팅을 할 때 무겁다 (CSS의 속성을 추가할 때(살을 입힐 때))
- 이러한 비싼 동작을 최소화 시켜준다. === 가상돔
- DOM이 1000번을 리렌더링을 해야하는 순간이 탄생할 수 있다.
- 1번으로 줄여서 렌더링 해준다.
- 작업을 모아서 처리를 한번에 해준다.

4. props와 state
- props
> 함수의 변수처럼 사용하는 느낌
> 자식이 부모에서 전달 받을 수 있는 값
> 부모 컴포넌트가 자식 컴포넌트에게 데이터를 전달하는 것.
> props를 전달할 때 `props 드릴링`을 최대한 피해서 잘 작성해햐 한다.
```js
    function a (props) {
        console.log(props)
    }
```

- state (상태 변수)
> 상태를 관리하기 위한 값
> 관리할 데이터를 유지 시키는게 목적
> 컴포넌트 : 객체, div 요소 느낌
> UI를 나눠놓은 단위 객체 컴포넌트의 내부에 값을 선언하고 페이지가 동작하는 동안 유지되고 변경될 데이터
> 예시 : 사용자가 입력값을 입력하면 관리하고 있다가 사용할 때 사용되는 변수
> 리액트는 상태값을 주시하고 있다가 상태가 변경되면 반응한다.

5. JSX
- 자바스크립트 XML, 자바스크립트 내에서 html과 유사한 코드를 작성할 수 있다.
```js
const a = "<div>123</div>" === X, 문자열
// 컴포넌트
const a = () => {
    const buttonHandler = () => {

    }
    return (
        <div>
            // 여기 부분이 바로 react의 컴포넌트에서 그려주는 UI
        </div>
    )
}
// 코드를 그대로 실행시키는지 ? 아니다.
// 트랜스파일 해서 변경된 파일을 실행해서 사용하는 것.
// JSX => js === 자바스크립트로 변환한다.
```
> react를 사용할 때 사용할 새로운 문법
> html 파일과 구문의 가독성을 높이고 내용을 줄여서 사용할 수 있다.
> `webpack`이 jsx 문법으로 작성한 파일을 js로 변환하고 번들링도 하기 위한 속성을 관리한다.
`webpack`이 중요, 만약 모르면 react 사용하지 말라는 말이 있을 정도임

```sh
# 바로 사용 X
# 보기만 할 것.
# project 폴더 이름에 대문자, react 들어가면 안됨
npx create-react-app [project 폴더 이름]
cd myapp
npm start

# 맥북
sudo npx create-react-app [project 폴더 이름]
cd myapp
sudo npm start
```


<!-- 보여주는 하나의 페이지를 중심으로 view가 중심인 어플리케이션
        react router dom 페이지가 이동한 것 같은 느낌을 줄 수 있다.
        페이지를 계속 생성하는게 아닌 가상돔으로 필요한 부분만 수정하고 갈아 끼워서 하나의 페이지를 계속 렌더 하는 것인지 여쭤보기 -->
<!-- 그러면 정말 아예 자식은 부모에게 데이터를 전달할 수 없는건지, 만약 자식에게 주고 다시 받아서 비교하고 싶거나 그러면 어떻게 할 수 있는지 => 아예 안됨 -->